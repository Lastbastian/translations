En el episodio de la semana pasada creamos un calendario básico con algunos estilos he incluimos nuestra libreria en una aplicación de Rails. Creamos tambien un par de parciales para mostrar la libreria "calendar". Asi que en este episodio, vamos a ir más allá. Vamos a añadir un poco de CoffeeScript de modo que si un elemento tiene una clase "today" y una clase "day", o una clase de "future" y la clase "day", vamos a hacer que ese elemento pueda ser clicleable a través CoffeeScript y que nos llevará a otra URL que crearemos hoy en la aplicación Rails. En esa URL se puede crear un evento, y guardar el mismo. Luego se va a redireccionar de nuevo al calendario y podríamos poder ver el evento dentro del día calendario. Vamos a escribir el código JavaScript para que esto suceda.

Comenzemos por envolver "document" en un objeto jQuery que nos da acceso al método "ready". Cuando el documento y jQuery se han cargado, vamos a coincidir para un elemento que tiene la clase "day" y la clase "today". Si existen esas 2 clases CSS en el elemento, vamos a vigilar ese elemento con una acción "clic". Cuando ese evento ocurra que vamos a ejecutar otra función anónima. En este momento, vamos a hacer una alert "wired". Si hacemos clic en el div que representa "today" en "day" debería darnos una alerta. Excelente!.

Ahora recargamos la página para ver lo que sucede cuando hacemos clic en el dia 19. Ahí está nuestro mensaje. jQuery esta efecto cableado y nuestras clases están siendo observados. No solo queremos ser sólo capazes de hacer clic en la fecha actual. También queremos ser capaces de hacer clic en un día en el futuro, así que tenemos que buscar la clase CSS de "day" y "future". Si tenemos un div que coincida con cualquiera de las dos, vamos a poder hacer clic sobre ellos.

Ahora que he vuelto a cargar debería poder no sólo hacer clic en el dia 19, sino también debería ser capaz de hacer clic en el dia 20. No debería sin embargo poder hacer clic en el dia 18, porque eso fue ayer. Ahi tienes.

El siguiente paso es, realmente no queremos hacer una alerta cuando esto suceda, queremos enviar al usuario a un lugar diferente, por ahora mantendremos las cosas simples. Vamos a escribir "window.location.href". Esto va a ser igual a "/events/new", que es simplemente una ruta REST Rails, sin embargo, esta ruta actualmente no existe. Muy bien, por lo que la página ha vuelto a cargar de nuevo. Si hago clic en el decimonoveno ahora, va a tratar de llevarnos a una ruta que no existe. Vamos a crear esa ruta en Rails ahora.

Para crear la ruta vamos a entrar en nuestro fichero "config/routes". Dentro del archivo de configuración de rutas vamos a añadir una nueva ruta. Esta vez va a ser una ruta plural, y que va a ser llamada "events". Sólo vamos a empezar con la acción en cuestión. Es decir sólo haremos la acción "new".

Si ahora voy a correr "rake routes", y a través de "| grep" vere cualquier cosa que tenga que ver con "event", debería obtener una ruta para "new event". Ahora, al recargar el navegador, encontraremos un error diferente. Ese error es que no existe el controlador.

Vamos a crear un controlador para los eventos, pero yo no voy a utilizar un generador. Voy a crear un archivo que será llamado "events_controller.rb". Será una clase "EventsController" que va a heredar de ApplicationController. En este momento sólo tenemos una acción en el mismo que se llama "new" y en esta acción que vamos a tener un nuevo "event" que va a ser igual a "Event.new".

Si recargamos la página de nuevo tendremos este error, y es porque no tenemos un modelo todavía. Vamos a crear el modelo ahora. Para esto utilizaremos un generador, "rails g model". El modelo se llama evento. Va a tener 1 atributo "name". Dado que el atributo es un string no necesitamos pasarle un argumento.

Luego migramos la base de datos debido a que creamos un modelo a través de un generador tenemos también una migración que coincide con el modelo. Ahora, con la migraron lista, al volver al navegador y refrescamos, obtenemos un nuevo error y es porque que la plantilla no se encuentra. Esto es correcto. Necesitamos una carpeta llamada "/events" dentro de nuestra carpeta de vistas y ahí necesitamos una vista llamada "new". Vamos a hacer eso.

Para crear esto vamos a crear una nueva carpeta llamada "events". En el interior vamos a crear una nueva vista llamada "new.html.erb" porque el archivo se va a terminar como HTML pero vamos a tener un pre-proccessor, osea erb. Pondré etiqueta básica de encabezado aquí sólo para identificar la página. Cuando recargamos la página de nuevo, obtenemos esta página donde dice "New event".

Es hora de poner el formulario en esta página para que cuando creemos un nuevo evento, nos redirija a nuestro calendario y podamos ver el evento en el día correcto. Voy a hacer eso en línea en este archivo. El objeto que el formulario va a operar es la variable de instancia que antes creamos en el controlador. Ya que "form_for" tendremos un bloque con la variable "f". En mi etiqueta final voy a usar un guión para que no imprima una línea vacía en mi HTML.

Ahora necesitamos un "text_field" que va a ser llamado "name", ya que es el atributo del modelo. Vamos a necesitar tambien un botón de envío. Conseguimos nuestro formulario así que vamos a llenar ese formulario. Llenemoslo con un nombre "Test 2". Ahora, tenemos "Unknown action, 'create' could not be found". Ya estaba esperando este error, así que podemos continuar y arreglarlo.

Para corregir este error, vamos a abrir el controlador y necesitaremos otra acción que se va a llama a "create". En la accion "create" vamos a establecer una variable de instancia "event" para "Event.new", muy similar a como lo hicimos en la acción "new". Sin embargo, ya que vamos a tener un parámetro proveniente de un formulario necesitaremos tener una lista blanca de estos parámetros para mantener nuestro sitio seguro de ser atacado.

Ya que el nombre del modelo es "event" el nombre para los parámetros de seguridad será "event_params" que sera un método parecido a este; empezamos con el objeto params que viene desde el controlador y vamos a requerir la clave "event" ya que ese es el nombre del modelo. luego vamos a permitir algunos atributos, en este caso, sólo el nombre. Si dejas sin el permiso aquí en algunas versiones anteriores de Rails simplemente se convierte en nula y no estás notificado. En algunas de las versiones más recientes realmente estás notificado.

Vamos correr esto de nuevo. Yo sólo voy a volver a publicar el formulario. Esta vez obtenemos un "Template missing error" y es porque al final de nuestro método se trata de un "create", es un "post", que no debe ser representación HTML. Asi que tenemos que re-direccionar si la acción tiene éxito y, recargar si no lo es. Para hacer eso, necesitamos acción "create".

Vamos a poner un "if" aquí para ver si el evento se pudo guardar. Si se puede, vamos a redirigir a "calendar_path". Si no podemos, vamos a volver a renderizar el formulario "new". Si refrescamos ahora, y enviamos el formulario de nuevo, tenemos acción exitosa. El evento fue creado en el calendario. Sin embargo, aún no tenemos el código en el calendario para pasar las fechas haciendo clic en ellas forma que acabamos de crear. Vamos a hacer eso ahora.

Tengo mi archivo CoffeeScript para el calendario y también el parcial que representa un dia abiertos. En el parcial que representa un día vamos a añadir un atributo nuevos datos que serán consumidos por el código JavaScript. Esta va a ser llamada "date", y que va a tener la fecha real completa, que se encuentra en la tupla del índice 0 en nuestra tupla "day". Creamos en el episodio 2. En esencia, el día contiene un número como 0-1 ó 1-2 ó 3-1, mientras que la fecha de fecha contiene el objeto de fecha completa.

Ahora bien, si refrescamos nuestro calendatio e inspeccionamos una de estas fechas, podemos ver que tiene el día de fecha de 19 y la fecha de "date" es 05/19/2015. Ahora, podemos tomarlo y usarlo con nuestro JavaScript. Guardemos  ese valor "date" accediendo a esta palabra en JavaScript. Vamos a envolverlo con jQuery para que nos de acceso al método "date" que saca el atributo para  "data" y la clave correspondiente. Queremos "date" por lo que vamos a fijar ese valor en la variable "date". Luego vamos a pasar por aquí en los parámetros. Eso va a necesitar una llave porque es un valor hash. Lo llamaremos fecha. "date" va a ser igual al valor de la fecha. Vamos cargar esto otra vez y pulsamos el dia 19, ahora nos lleva a nuestro evento "new", solo que esta vez la fecha se ha pasado a través de los parámetros.

Con el fin de persistir ese valor en en el modelo tenemos que ponerlo en nuestro formulario. Vamos a hacer eso con un campo oculto y vamos a llamarlo "occurs_on". Vamos a darle un valor, este valor va a venir del hash "params" donde la clave es "fecha".

Si examinamos este elemento podemos ver que hay otra entrada. Está escondida y tiene el campo de fecha que queremos. El nombre del elemento es de eventos y luego "[occurs_on]" porque es una convención en Rails. El modelo es primero y luego el atributo. Entonces el id es otra convención Rails para pasar datos del formulario a los objetos. Eso va a ser "events_occurs_on". Ahora, creamos una migración para agregar el campo occurs_on a nuestra mesa Eventos. Luego migramos nuestra base de datos.

Lo siguiente que tenemos que hacer en el controlador es añadirlo al hash de params para que no se filte. Probemoslo de nuevo, esta vez vamos a hacer clic en el 20 y creemos una fecha, llamemoslo simplemente "future date". "create event" Nos lleva de nuevo al calendario, y vamos a entrar en la consola de Rails, aqui podemos ver que nuestros datos están bien, así que si inspeccionamos el último elemento creado, podemos ver que tiene un "occurs_on" de 05/20/2015, que fue la fecha en la que hicimos clic, por lo que funcionó. Esta pasó a través de la capa de JavaScript a la capa del controlador, luego por la capa del modelo y se guardo en la base de datos.

Por último, tenemos que visualizar este evento en nuestro calendario debajo de la fecha correcta. Eso va a ocurrir en el interior del parcial. Todo lo que tenemos que hacer ahora es renderizar el parcial situado en "events/event". Tenemos que darle un poco de información, algunos datos. Vamos a hacer eso con la palabra clave "collection". Lo que vamos a hacer es, vamos a pasarle "Event.for_date". Eso va a tomar una fecha y "date" va a ser la fecha que le pasamos por lo que es la primera parte de nuestra tupla.

Ahora, vamos a tener que crear ese "scope" dentro de nuestro modelo. Para que cuando actualice la página se pueda ver el evento que tenemos en nuestro en el calendario para el 20, que fue el que elegimos.

Asi que eso fue todo por esta semana en RubyCasts. A pedido de ustedes la semana que viene vamos comenzar con contenido un poco más para principiates, para aquellos de ustedes que están recién graduados de Dev Bootcamps y no han pasado demasiado tiempo en Rubyland. Nos vemos el próximo martes.