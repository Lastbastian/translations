Al final del episodio de la semana pasada creamos un calendario como el que podemos ver aquí. Este calendario puede tener varios eventos y estos eventos se mostrarán en la fecha del calendario. Pero hay un problema aquí, al revisar por debajo. Si vemos nuestra consulta SQL que se genera, podemos ver que no tenemos solamente una consulta SQL. Si no que de hecho tenemos 42 consultas SQL, una por cada día del calendario. Hoy vamos a arreglar eso.

Vamos a empezar con el parcial culpable que está aquí "calendar/views" "calendar_days". Este parcial se renderiza 42 veces. Y ya que se renderiza 42 veces en este calendario particularmente, tenemos a "active record" haciendo las mismas 42 consultas, en lugar de esperar a que todos los datos se transmitan. Lo qué quiero decir con esto es que actualmente estamos pasando esta variable "day", un array, que en realidad es una tupla, la cual actualmente cuenta con dos valores. El primer valor es la fecha del día que debe renderizarse. El segundo valor es el conjunto de clases CSS que deben ser presentados en el parcial. Lo tercero que vamos a añadir ahora serán los eventos que renderizará el parcial ya que pertenecen a una fecha específica.

Necesitamos abrir nuestro calendario. Opcionalmente ahora ya deberiamos poder pasar los eventos. Pero eso nos presenta un problema. Ya tenemos un parámetro opcional aquí, la fecha pero no podemos tener dos. Afortunadamente ruby también nos da una forma de evitar esto. Podemos utilizar palabras clave como argumentos, crearemos un argumento de palabra clave denominada "events" que por defecto es una matriz vacía y una llamada "date" cuyo argumento va a ser por defecto "date.today".

Ahora vamos a tener que persistir esos eventos. Utilizaremos una variable de instancia y vamos a ponerla en los eventos que pasamos. Esta tupla contiene la fecha y los estilos, una para cada fecha que se encuentra en la matriz. Lo que vamos a hacer aquí es añadir otro valor a la tupla y que va a ser un método privado local llamado "events" los cuales llevan una fecha.

Ahora vamos a crear ese método privado. Va a ser llamado "events_for". Se necesita una fecha. Vamos a seleccionar sobre la variable de instancia eventos. A continuación, comprobaremos cada uno de estos eventos y la fecha en la que se producen. Si esa fecha es la misma que la fecha que fue pasada en el método la devolveremos como un nuevo array de eventos.

Ahora los eventos en este día en particular se pondrán en la tupla. Lo último que vamos a tener que cambiar aquí está dentro del controlador de nuestro calendario y es que debemos pasar los eventos de la capa de "active record" en el calendario. Esto los haremos llamando a su palabra clave "events", y lo vamos a poner en un unico método.

Hago esto porque realmente no me gustan variables locales fastidiando en mi método. Si tengo una variable local es muy probable que pueda ser un método. Asi que voy a extraer esto en un método que ahora se llama "events". Este método se va a memorizar un array de eventos para "event.where" y vamos a tener que revisar a lo que ocurre en "date" además conseguir todos aquellos eventos que ocurran entre la fecha uno y la fecha dos que está representado por estas dos marcas de pregunta.

Ya que pasamos los dos signos de interrogación a la consulta SQL necesitamos darle dos valores. La primera de ellas es la primera fecha del calendario, y la segunda es la última fecha del calendario. Si has estado siguiendo esta serie podrás observar que tenemos la primera fecha del calendario y última fecha del calendario definido en el fondo de ese objeto calendario. Pero yo no voy a sacar esos detalles locales privados fuera de la encapsulación en que los tenía sólo para poder usarlos aquí en el controlador.

No tiene sentido ir de Rails el cual ya tiene "active support" en una clase de Ruby, a obtener acceso a "active support" y luego volver a Rails. Asi que simplemente vamos a crearla aquí, algo muy parecido a esto. Comenzemos con "date.today". Luego vamos a ir a "beginning_of_month" y el "beginning_of_week" que comienza con el domingo. Simplemente voy a copiar este método ya que el siguiente método se parece mucho a este método con algunas pequeñas diferencias. Vamos a ir hasta "last_calendar_day" y vamos a hacer "end_of_month" y "end_of_weel" partir de domingo.

Nuestro trabajo hasta aquí debería estar completo. Deberiamos poder reiniciar el servidor de Rails, y a continuación, actualizar la página y tener una sola consulta SQL en lugar de 42. Nuestra página ha recargado sin ningún cambio en la funcionalidad, lo cual es bueno. Vamos a los registros y podemos ver que tenemos una gran cantidad de eventos y un montón de parciales "day" siendo renderizados, pero con sólo una llamada a la base de datos que está justo aquí con esta carga los eventos de "events" que se producen entre esa fecha y la otra.

Con esto terminamos la serie para nuestra aplicacion. La próxima semana vamos a empezar con una nueva aplicación. Espero verlos entonces.